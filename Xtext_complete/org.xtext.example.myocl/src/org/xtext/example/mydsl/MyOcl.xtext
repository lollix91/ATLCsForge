grammar org.xtext.example.mydsl.MyOcl with org.eclipse.xtext.common.Terminals





generate myOcl "http://www.xtext.org/example/mydsl/MyOcl"

CompleteOCLDocumentCS:
	ownedImports+=ImportCS*
	(ownedPackages+=PackageDeclarationCS | ownedContexts+=ContextDeclCS)*;





ClassifierContextDeclCS :
	'context' (ownedSignature=TemplateSignatureCS)? (selfName=UnrestrictedName)?
	ownedPathName=pathNameCS	
	(('inv' ownedInvariants+=ConstraintCS)
	| ownedDefinitions+=DefCS
	)+;





terminal UNQUOTED_STRING:	
	'£$%^£$%^'				
;

CompleteOCLNavigationOperatorName:
	'^' | '^^';


	





	
/*
 * A Constraint such as 
 * 
 * oclText[IsNull('should be null') : self = null]
 * 
 * comprises at least the OCL specification of the constraint. The constraint may
 * additionally have a name which may be followed by a parenthesized expression defining an OCL
 * expression to be evaluated to provide an error message.
 */
ConstraintCS :
	(name=UnrestrictedName ('(' ownedMessageSpecification=SpecificationCS ')')?)? ':' ownedSpecification=SpecificationCS;

/*
 * A Context declaration can be a Classifier, Operation of Property Context declaration.
 */
ContextDeclCS:
	PropertyContextDeclCS
	| ClassifierContextDeclCS
	| OperationContextDeclCS;

/*
 * A definition can be an, Operation or Property definition.
 */
DefCS:
	DefOperationCS|DefPropertyCS;

/*
 * An operation definition provides an additional operation for its classifier context.
 * 
 * oclText[static def redundantName: isEven(i : Integer) : Boolean = i mod 2 = 0]
 * 
 * comprises at least an operation name, return type and an OCL expression that evaluates the operation value.
 * The operation may have parameters and may be declared static in which case there is no oclText[self].
 * 
 * For compatibility with invariants the definition may have a name that is never used.
 */
DefOperationCS:
	(isStatic?='static')? 'def' UnrestrictedName? ':' (ownedSignature=TemplateSignatureCS)?
		name=UnrestrictedName '(' (ownedParameters+=DefParameterCS (',' ownedParameters+=DefParameterCS)*)? ')' ':' (ownedType=TypeExpCS)?
		 '=' ownedSpecification=SpecificationCS;

DefParameterCS :
	name=UnrestrictedName ':' ownedType=TypeExpCS;

/*
 * A property definition provides an additional property for its classifier context.
 * 
 * oclText[static def redundantName: upperCaseName : Boolean = name.toUpperCase()]
 * 
 * comprises at least a property name, type and an OCL expression that evaluates the property value.
 * The property may be declared static in which case there is no oclText[self].
 * 
 * For compatibility with invariants the definition may have a name that is never used.
 */
DefPropertyCS :
	(isStatic?='static')? 'def' UnrestrictedName? ':' name=UnrestrictedName ':' ownedType=TypeExpCS
		'=' ownedSpecification=SpecificationCS;

ImportCS :
	('import' | 'include' | 'library') (name=Identifier ':')? ownedPathName=URIPathNameCS (isAll?='::*')?;

URIPathNameCS:
	pathNameCS
;

Identifier:
	SIMPLE_ID
;

/*
 * An operation context declaration complements an existing operation with additional details.
 * 
 * oclText[context (T) Stack::pop() : T]
 * oclText[pre NotEmptyPop: size() > 0]
 * oclText[post: size()@pre = size() + 1]
 * 
 * The operation declaration comprises at least an operation name, which must be qualified with at least a
 * class name. If used outside a package declaration, package name qualification is also needed. 
 * If the return type is omitted OclVoid is used.
 * The operation may also have operation parameters and template parameters.
 * The declaration may be followed by any number of preconditions,
 * and/or postconditions. It may also be followed by a body expression that defines the evaluation. 
 * 
 * For compatibility with invariants the body expression may have a name that is never used.
 */
OperationContextDeclCS:
	'context' (ownedSignature=TemplateSignatureCS)? ownedPathName=pathNameCS
	'(' (ownedParameters+=ParameterCS (',' ownedParameters+=ParameterCS)*)? ')' ':' (ownedType=TypeExpCS)?
	(('pre' ownedPreconditions+=ConstraintCS)
	| ('post' ownedPostconditions+=ConstraintCS)
	| ('body' UnrestrictedName? ':' ownedBodies+=SpecificationCS)
	)*;

PackageDeclarationCS:
	'package' ownedPathName=pathNameCS ('inv' ownedInvariants+=ConstraintCS)* (ownedContexts+=ContextDeclCS)* 'endpackage';

ParameterCS:
	(name=UnrestrictedName ':')? ownedType=TypeExpCS;
	
	




/*
 * A property context declaration complements an existing property with additional details.
 * 
 * oclText[context (T) Stack::isEmpty : Boolean]
 * oclText[derive IsEmpty: size() = 0]
 * 
 * The property declaration comprises at least a property name and type.
 * The type must be qualified with at least a class name.
 * If used outside a package declaration, package name qualification is also needed. 
 * The declaration may be followed by a derive constraint and/or an init expression.
 * 
 * A derive constraint provides an alternate mechanism for defining a class invariant;
 * the only difference is that the property is identified as a constrainedElement. As an
 * invariant the constraint provides an OCL expression that should always be true.
 * 
 * For a non-derived property, an init expression defines the value to be assigned to the property
 * when its containing object is first created. 
 * 
 * For a derived property, an init expression defines the evaluation of the property, which
 * may vary from access to access even for read-only properties. 
 */
PropertyContextDeclCS returns PropertyContextDeclCS:
	'context' ownedPathName=pathNameCS ':' ownedType=TypeExpCS
	(('derive' ownedDerivedInvariants+=ConstraintCS)
	| ('init' ':' ownedDefaultExpressions+=SpecificationCS)
	)*;

SpecificationCS :
	ownedExpression=ExpCS | exprString=UNQUOTED_STRING;
	
 pathNameCS : 
 	name=simpleNameCS  "::" UnrestrictedName2
 ;

simpleNameCS:
	SIMPLE_ID
;



 





		

//---------------------------------------------------------------------------------
//	Base overrides
//---------------------------------------------------------------------------------



TemplateSignatureCS :
	('(' ownedParameters+=TypeParameterCS (',' ownedParameters+=TypeParameterCS)* ')')
|	('<' ownedParameters+=TypeParameterCS (',' ownedParameters+=TypeParameterCS)* '>')
;

TypeParameterCS:
	PrimitiveTypeCS
;


TypedRefCS:
	TypeLiteralCS //| TypedTypeRefCS
;






UnrestrictedName:
	EssentialOCLUnrestrictedName
	//| 'body'
	//| 'context'
	//| 'def'
	//| 'derive'
	//|	'endpackage'
	| 'import'
	| 'include'
	//| 'init'
	//| 'inv'
	| 'library'
	//|	'package'
	//|	'post'
	//|	'pre'
	//|	'static'
;

//---------------------------------------------------------------------------------
//	EssentialOCL overrides
//---------------------------------------------------------------------------------
NavigatingArgExpCS :
	({OCLMessageArgCS} '?')
	| ExpCS
;

NavigationOperatorName:
	EssentialOCLNavigationOperatorName | CompleteOCLNavigationOperatorName;

EssentialOCLNavigationOperatorName:
	EssentialOCLNavigationOperator
;

terminal DOUBLE_QUOTED_STRING:
	'"' ('\\'('b' | 't'| 'n' | 'f' | 'r'  | 'u'  | '"'  | "'"
		| '\\') | !('\\' | '"'))* '"'	
;

terminal SINGLE_QUOTED_STRING:
	"'" ('\\'('b' | 't'| 'n' | 'f' | 'r'  | 'u'  | '"'  | "'"
		| '\\') | !('\\' | "'"))* "'"	
;
terminal ML_SINGLE_QUOTED_STRING:
	"/'"->"'/"
;
terminal SIMPLE_ID:
	('a'..'z' | 'A'..'Z'|'_') ('a'..'z'|'A'..'Z' | '_' | '0'..'9')*
;

terminal BIG_INT :
	('0'..'9')+
;
terminal DOCUMENTATION:
	'/**'->'*/'
;
@Override
terminal ML_COMMENT:
	'/*' !('\n' | '\r')* ('\r'? '\n')?
;
@Override
terminal SL_COMMENT:
	'--' !('\n' | '\r')* ('\r'? '\n')?
;
@Override
terminal WS:
	(' ' | '\t' | '\r'| '\n')+
;
@Override
terminal ANY_OTHER:
	.
;

EssentialOCLRersevedKeyword:
	'and' | 'else' | 'endif' | 'if' | 'implies' | 'in' | 'let' 
	| 'not' | 'or' | 'then' | 'xor'
;
EssentialOCLPrefixOperator:
	'-' | 'not'
;
EssentialOCLInfixOperator:
	'*' | '/' | '+' | '-' | '>' | '<' | '>=' | '<=' | '=' | '<>' | 'and'
	| 'or' | 'xor' | 'implies'
;
EssentialOCLNavigationOperator:
	'.' | '->'
;

StringLiteral:
	SINGLE_QUOTED_STRING
;

PrefixOperator:
	EssentialOCLPrefixOperator
;
InfixOperator:
	EssentialOCLInfixOperator
;
NavigationOperator:
	EssentialOCLNavigationOperator
;



EssentialOCLUnrestrictedName:
	SIMPLE_ID
;

UnrestrictedName2:
	EssentialOCLUnrestrictedName
;

EssentialOCLUnreservedName:
	UnrestrictedName | CollectionTypeIdentifier |  PrimitiveTypeIdentifier | 'Tuple'
	
;
UnreservedName:
	EssentialOCLUnreservedName
;
PrimitiveTypeIdentifier:
	'Boolean' | 'Integer' | 'Real' | 'String' | 'UnlimitedNatural' | 'OclAny'
	| 'OclInvalid' | 'OclVoid'
;
PrimitiveTypeCS :
	name=PrimitiveTypeIdentifier
;
CollectionTypeIdentifier :
	'Set' | 'Bag' | 'Sequence' | 'Collection' | 'OrderedSet'
;
CollectionTypeCS:
	name=CollectionTypeIdentifier (('(' ownedType=TypeExpCS ')')
		| ('<' ownedType=TypeExpCS '>'))?
;



TupleTypeCS :
	name='Tuple'
	(('(' (ownedParts+=tuplePartCS (',' ownedParts+=tuplePartCS)*)? ')')
		| ('<' (ownedParts+=tuplePartCS (',' ownedParts+=tuplePartCS)*)?'>'))?
		backtrack="true"
;
 

tuplePartCS :
	name=UnrestrictedName ':' ownedType=TypeExpCS
;

CollectionLiteralExpCS :
	ownedType=CollectionTypeCS
	'{' (ownedParts+=CollectionLiteralPartCS (',' ownedParts+=CollectionLiteralPartCS)*)?'}'
;
CollectionLiteralPartCS :
	expressionCS=ExpCS ('..' lastExpressionCS=ExpCS)?
;

PrimitiveLiteralExpCS :
	NumberLiteralExpCS | StringLiteralExpCS | BooleanLiteralExpCS 
	| UnlimitedNaturalLiteralExpCS | InvalidLiteralExpCS | NullLiteralExpCS
;
TupleLiteralExpCS :
	'Tuple' '{' ownedParts+=TupleLiteralPartCS (','
		ownedParts+=TupleLiteralPartCS)* '}'
;
TupleLiteralPartCS :
	name=UnrestrictedName (':' ownedType=TypeExpCS)? '='
	initExpression=ExpCS
;
NumberLiteralExpCS:
	name=BIG_INT
;
StringLiteralExpCS :
	name+=StringLiteral
;
BooleanLiteralExpCS :
	name='true' | name='false'
	
;

UnlimitedNaturalLiteralExpCS :
	{UnlimitedNaturalLiteralExpCS} '*'
;
InvalidLiteralExpCS :
	{InvalidLiteralExpCS} 'invalid'
;
NullLiteralExpCS:
	{NullLiteralExpCS} 'null'
;



TypeLiteralCS :
	PrimitiveTypeCS  | TupleTypeCS | CollectionTypeCS 
;
TypeLiteralExpCS:
	ownedType=TypeLiteralCS
;


 
TypeNameExpCS:
	(((namespace+=UnrestrictedName '::'
		(namespace +=UnreservedName '::')*)
		element=UnreservedName) | element=UnrestrictedName);
		


TypeExpCS :
	TypeNameExpCS | TypeLiteralCS
;
	


NavigatingArgCS :
	name=NavigatingArgExpCS (':' ownedType=TypeExpCS)? ('=' init=ExpCS)?;
	
NavigatingBarArgCS :
	prefix='|' name=NavigatingArgExpCS (':' ownedType=TypeExpCS)? ('=' init=ExpCS)?;

NavigatingCommaArgCS :
	prefix=',' name=NavigatingArgExpCS (':' ownedType=TypeExpCS)? ('=' init=ExpCS)?;
		
NavigatingSemiArgCS :
	prefix=';' name=NavigatingArgExpCS (':' ownedType=TypeExpCS)? ('=' init=ExpCS)?;


	
IfExpCS:
	'if' condition=ExpCS
	'then' thenExpression=ExpCS
	'else' elseExpression=ExpCS
	'endif';
LetExpCS :
	'let' variable+=LetVariableCS (',' variable+=LetVariableCS)*
	'in' in=ExpCS;
	
LetVariableCS:
	name=UnrestrictedName (':'ownedType=TypeExpCS)? '='
	initExpression=ExpCS;
	
NestedExpCS :
	'(' source=ExpCS ')';
	
SelfExpCS:
	{SelfExpCS}'self';
	
PrimaryExpCS:
	NavigatingExpCS | SelfExpCS | PrimitiveLiteralExpCS | TupleLiteralExpCS |
	CollectionLiteralExpCS  | LetExpCS | IfExpCS | NestedExpCS;
	
NameExpCS :
	(((namespace+=UnrestrictedName '::'
		(namespace +=UnreservedName '::')*)
		element=UnreservedName) | element=UnrestrictedName);
		
		
ExpCS :
	InfixedExpCS
;


InfixedExpCS :
	PrefixedExpCS ({InfixExpCS.ownedExpression+=current}
	(ownedOperator+=BinaryOperatorCS ownedExpression+=PrefixedExpCS)+)? ;

BinaryOperatorCS :
	InfixOperatorCS | NavigationOperatorCS ;
	
InfixOperatorCS :
	name=InfixOperator ;
	
NavigationOperatorCS  :
	name=NavigationOperator ;


PrefixedExpCS :
	PrimaryExpCS | ({PrefixExpCS} ownedOperator+=UnaryOperatorCS+
		ownedExpression=PrimaryExpCS) ;
		
UnaryOperatorCS :
	name=PrefixOperator ;
	

IndexExpCS :
	NameExpCS
	({IndexExpCS.namedExp=current}
		'[' firstIndexes+=ExpCS (',' firstIndexes+=ExpCS)* ']'
		('[' secondIndexes+=ExpCS (',' secondIndexes+=ExpCS)* ']')?)?;
		
NavigatingExpCS_Base :
	IndexExpCS
;

NavigatingExpCS :
	NavigatingExpCS_Base 
	({NavigatingExpCS.namedExp=current}
		'(' (argument+=NavigatingArgCS (argument+=NavigatingCommaArgCS)*
			(argument+=NavigatingSemiArgCS
				(argument+=NavigatingCommaArgCS)*)?
				(argument+=NavigatingBarArgCS (argument+=NavigatingCommaArgCS)*)?)?')'
					) ?;

