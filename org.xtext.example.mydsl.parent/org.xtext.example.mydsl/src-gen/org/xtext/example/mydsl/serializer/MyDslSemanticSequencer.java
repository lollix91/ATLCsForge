/*
 * generated by Xtext 2.11.0
 */
package org.xtext.example.mydsl.serializer;

import atl.ActionBlock;
import atl.AtlPackage;
import atl.Binding;
import atl.BindingStat;
import atl.CalledRule;
import atl.DropPattern;
import atl.ExpressionStat;
import atl.ForEachOutPatternElement;
import atl.ForStat;
import atl.Helper;
import atl.IfStat;
import atl.InPattern;
import atl.LazyMatchedRule;
import atl.Library;
import atl.LibraryRef;
import atl.MatchedRule;
import atl.Module;
import atl.OutPattern;
import atl.Query;
import atl.RuleVariableDeclaration;
import atl.SimpleInPatternElement;
import atl.SimpleOutPatternElement;
import atl.Unit;
import com.google.inject.Inject;
import java.util.Set;
import ocl.Attribute;
import ocl.BagExp;
import ocl.BagType;
import ocl.BooleanExp;
import ocl.BooleanType;
import ocl.CollectionOperationCallExp;
import ocl.CollectionType;
import ocl.EnumLiteralExp;
import ocl.IfExp;
import ocl.IntegerExp;
import ocl.IntegerType;
import ocl.IterateExp;
import ocl.Iterator;
import ocl.IteratorExp;
import ocl.LetExp;
import ocl.MapElement;
import ocl.MapExp;
import ocl.MapType;
import ocl.NavigationOrAttributeCallExp;
import ocl.OclAnyType;
import ocl.OclContextDefinition;
import ocl.OclFeatureDefinition;
import ocl.OclModel;
import ocl.OclModelElement;
import ocl.OclPackage;
import ocl.OclType;
import ocl.OclUndefinedExp;
import ocl.Operation;
import ocl.OperationCallExp;
import ocl.OperatorCallExp;
import ocl.OrderedSetExp;
import ocl.OrderedSetType;
import ocl.RealExp;
import ocl.RealType;
import ocl.SequenceExp;
import ocl.SequenceType;
import ocl.SetExp;
import ocl.SetType;
import ocl.StringExp;
import ocl.StringType;
import ocl.SuperExp;
import ocl.TupleExp;
import ocl.TuplePart;
import ocl.TupleType;
import ocl.TupleTypeAttribute;
import ocl.VariableDeclaration;
import ocl.VariableExp;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == AtlPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case AtlPackage.ACTION_BLOCK:
				sequence_ActionBlock(context, (ActionBlock) semanticObject); 
				return; 
			case AtlPackage.BINDING:
				sequence_Binding(context, (Binding) semanticObject); 
				return; 
			case AtlPackage.BINDING_STAT:
				sequence_BindingStat(context, (BindingStat) semanticObject); 
				return; 
			case AtlPackage.CALLED_RULE:
				sequence_CalledRule(context, (CalledRule) semanticObject); 
				return; 
			case AtlPackage.DROP_PATTERN:
				sequence_DropPattern(context, (DropPattern) semanticObject); 
				return; 
			case AtlPackage.EXPRESSION_STAT:
				sequence_ExpressionStat(context, (ExpressionStat) semanticObject); 
				return; 
			case AtlPackage.FOR_EACH_OUT_PATTERN_ELEMENT:
				sequence_ForEachOutPatternElement(context, (ForEachOutPatternElement) semanticObject); 
				return; 
			case AtlPackage.FOR_STAT:
				sequence_ForStat(context, (ForStat) semanticObject); 
				return; 
			case AtlPackage.HELPER:
				sequence_Helper(context, (Helper) semanticObject); 
				return; 
			case AtlPackage.IF_STAT:
				sequence_IfStat(context, (IfStat) semanticObject); 
				return; 
			case AtlPackage.IN_PATTERN:
				sequence_InPattern(context, (InPattern) semanticObject); 
				return; 
			case AtlPackage.LAZY_MATCHED_RULE:
				sequence_LazyMatchedRule(context, (LazyMatchedRule) semanticObject); 
				return; 
			case AtlPackage.LIBRARY:
				sequence_Library(context, (Library) semanticObject); 
				return; 
			case AtlPackage.LIBRARY_REF:
				sequence_LibraryRef(context, (LibraryRef) semanticObject); 
				return; 
			case AtlPackage.MATCHED_RULE:
				sequence_MatchedRule_Impl(context, (MatchedRule) semanticObject); 
				return; 
			case AtlPackage.MODULE:
				sequence_Module(context, (Module) semanticObject); 
				return; 
			case AtlPackage.OUT_PATTERN:
				sequence_OutPattern(context, (OutPattern) semanticObject); 
				return; 
			case AtlPackage.QUERY:
				sequence_Query(context, (Query) semanticObject); 
				return; 
			case AtlPackage.RULE_VARIABLE_DECLARATION:
				sequence_RuleVariableDeclaration(context, (RuleVariableDeclaration) semanticObject); 
				return; 
			case AtlPackage.SIMPLE_IN_PATTERN_ELEMENT:
				sequence_SimpleInPatternElement(context, (SimpleInPatternElement) semanticObject); 
				return; 
			case AtlPackage.SIMPLE_OUT_PATTERN_ELEMENT:
				sequence_SimpleOutPatternElement(context, (SimpleOutPatternElement) semanticObject); 
				return; 
			case AtlPackage.UNIT:
				sequence_Unit_Impl(context, (Unit) semanticObject); 
				return; 
			}
		else if (epackage == OclPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case OclPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case OclPackage.BAG_EXP:
				sequence_BagExp(context, (BagExp) semanticObject); 
				return; 
			case OclPackage.BAG_TYPE:
				sequence_BagType(context, (BagType) semanticObject); 
				return; 
			case OclPackage.BOOLEAN_EXP:
				sequence_BooleanExp(context, (BooleanExp) semanticObject); 
				return; 
			case OclPackage.BOOLEAN_TYPE:
				sequence_BooleanType(context, (BooleanType) semanticObject); 
				return; 
			case OclPackage.COLLECTION_OPERATION_CALL_EXP:
				sequence_CollectionOperationCallExp(context, (CollectionOperationCallExp) semanticObject); 
				return; 
			case OclPackage.COLLECTION_TYPE:
				sequence_CollectionType_Impl(context, (CollectionType) semanticObject); 
				return; 
			case OclPackage.ENUM_LITERAL_EXP:
				sequence_EnumLiteralExp(context, (EnumLiteralExp) semanticObject); 
				return; 
			case OclPackage.IF_EXP:
				sequence_IfExp(context, (IfExp) semanticObject); 
				return; 
			case OclPackage.INTEGER_EXP:
				sequence_IntegerExp(context, (IntegerExp) semanticObject); 
				return; 
			case OclPackage.INTEGER_TYPE:
				sequence_IntegerType(context, (IntegerType) semanticObject); 
				return; 
			case OclPackage.ITERATE_EXP:
				sequence_IterateExp(context, (IterateExp) semanticObject); 
				return; 
			case OclPackage.ITERATOR:
				sequence_Iterator(context, (Iterator) semanticObject); 
				return; 
			case OclPackage.ITERATOR_EXP:
				sequence_IteratorExp(context, (IteratorExp) semanticObject); 
				return; 
			case OclPackage.LET_EXP:
				sequence_LetExp(context, (LetExp) semanticObject); 
				return; 
			case OclPackage.MAP_ELEMENT:
				sequence_MapElement(context, (MapElement) semanticObject); 
				return; 
			case OclPackage.MAP_EXP:
				sequence_MapExp(context, (MapExp) semanticObject); 
				return; 
			case OclPackage.MAP_TYPE:
				sequence_MapType(context, (MapType) semanticObject); 
				return; 
			case OclPackage.NAVIGATION_OR_ATTRIBUTE_CALL_EXP:
				sequence_NavigationOrAttributeCallExp(context, (NavigationOrAttributeCallExp) semanticObject); 
				return; 
			case OclPackage.OCL_ANY_TYPE:
				sequence_OclAnyType(context, (OclAnyType) semanticObject); 
				return; 
			case OclPackage.OCL_CONTEXT_DEFINITION:
				sequence_OclContextDefinition(context, (OclContextDefinition) semanticObject); 
				return; 
			case OclPackage.OCL_FEATURE_DEFINITION:
				sequence_OclFeatureDefinition(context, (OclFeatureDefinition) semanticObject); 
				return; 
			case OclPackage.OCL_MODEL:
				sequence_OclModel(context, (OclModel) semanticObject); 
				return; 
			case OclPackage.OCL_MODEL_ELEMENT:
				sequence_OclModelElement(context, (OclModelElement) semanticObject); 
				return; 
			case OclPackage.OCL_TYPE:
				sequence_OclType_Impl(context, (OclType) semanticObject); 
				return; 
			case OclPackage.OCL_UNDEFINED_EXP:
				sequence_OclUndefinedExp(context, (OclUndefinedExp) semanticObject); 
				return; 
			case OclPackage.OPERATION:
				sequence_Operation(context, (Operation) semanticObject); 
				return; 
			case OclPackage.OPERATION_CALL_EXP:
				sequence_OperationCallExp_Impl(context, (OperationCallExp) semanticObject); 
				return; 
			case OclPackage.OPERATOR_CALL_EXP:
				sequence_OperatorCallExp(context, (OperatorCallExp) semanticObject); 
				return; 
			case OclPackage.ORDERED_SET_EXP:
				sequence_OrderedSetExp(context, (OrderedSetExp) semanticObject); 
				return; 
			case OclPackage.ORDERED_SET_TYPE:
				sequence_OrderedSetType(context, (OrderedSetType) semanticObject); 
				return; 
			case OclPackage.PARAMETER:
				sequence_Parameter(context, (ocl.Parameter) semanticObject); 
				return; 
			case OclPackage.REAL_EXP:
				sequence_RealExp(context, (RealExp) semanticObject); 
				return; 
			case OclPackage.REAL_TYPE:
				sequence_RealType(context, (RealType) semanticObject); 
				return; 
			case OclPackage.SEQUENCE_EXP:
				sequence_SequenceExp(context, (SequenceExp) semanticObject); 
				return; 
			case OclPackage.SEQUENCE_TYPE:
				sequence_SequenceType(context, (SequenceType) semanticObject); 
				return; 
			case OclPackage.SET_EXP:
				sequence_SetExp(context, (SetExp) semanticObject); 
				return; 
			case OclPackage.SET_TYPE:
				sequence_SetType(context, (SetType) semanticObject); 
				return; 
			case OclPackage.STRING_EXP:
				sequence_StringExp(context, (StringExp) semanticObject); 
				return; 
			case OclPackage.STRING_TYPE:
				sequence_StringType(context, (StringType) semanticObject); 
				return; 
			case OclPackage.SUPER_EXP:
				sequence_SuperExp(context, (SuperExp) semanticObject); 
				return; 
			case OclPackage.TUPLE_EXP:
				sequence_TupleExp(context, (TupleExp) semanticObject); 
				return; 
			case OclPackage.TUPLE_PART:
				sequence_TuplePart(context, (TuplePart) semanticObject); 
				return; 
			case OclPackage.TUPLE_TYPE:
				sequence_TupleType(context, (TupleType) semanticObject); 
				return; 
			case OclPackage.TUPLE_TYPE_ATTRIBUTE:
				sequence_TupleTypeAttribute(context, (TupleTypeAttribute) semanticObject); 
				return; 
			case OclPackage.VARIABLE_DECLARATION:
				sequence_VariableDeclaration_Impl(context, (VariableDeclaration) semanticObject); 
				return; 
			case OclPackage.VARIABLE_EXP:
				sequence_VariableExp(context, (VariableExp) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ActionBlock returns ActionBlock
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         (statements+=Statement statements+=Statement*)?
	 *     )
	 */
	protected void sequence_ActionBlock(ISerializationContext context, ActionBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclFeature returns Attribute
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         name=String0 
	 *         initExpression=OclExpression 
	 *         type=OclType
	 *     )
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns BagExp
	 *     BagExp returns BagExp
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         type=OclType? 
	 *         (elements+=OclExpression elements+=OclExpression*)?
	 *     )
	 */
	protected void sequence_BagExp(ISerializationContext context, BagExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns BagType
	 *     OclType returns BagType
	 *     BagType returns BagType
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         name=String0 
	 *         type=OclType? 
	 *         elementType=OclType
	 *     )
	 */
	protected void sequence_BagType(ISerializationContext context, BagType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns BindingStat
	 *     BindingStat returns BindingStat
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         propertyName=String0 
	 *         isAssignment=Boolean 
	 *         source=OclExpression 
	 *         value=OclExpression
	 *     )
	 */
	protected void sequence_BindingStat(ISerializationContext context, BindingStat semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Binding returns Binding
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         propertyName=String0 
	 *         isAssignment=Boolean 
	 *         value=OclExpression
	 *     )
	 */
	protected void sequence_Binding(ISerializationContext context, Binding semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns BooleanExp
	 *     BooleanExp returns BooleanExp
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         booleanSymbol=Boolean 
	 *         type=OclType?
	 *     )
	 */
	protected void sequence_BooleanExp(ISerializationContext context, BooleanExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns BooleanType
	 *     OclType returns BooleanType
	 *     BooleanType returns BooleanType
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         name=String0 
	 *         type=OclType?
	 *     )
	 */
	protected void sequence_BooleanType(ISerializationContext context, BooleanType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModuleElement returns CalledRule
	 *     CalledRule returns CalledRule
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         name=String0 
	 *         isEntrypoint=Boolean 
	 *         isEndpoint=Boolean 
	 *         outPattern=OutPattern? 
	 *         actionBlock=ActionBlock? 
	 *         (variables+=RuleVariableDeclaration variables+=RuleVariableDeclaration*)? 
	 *         (parameters+=Parameter parameters+=Parameter*)?
	 *     )
	 */
	protected void sequence_CalledRule(ISerializationContext context, CalledRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns CollectionOperationCallExp
	 *     CollectionOperationCallExp returns CollectionOperationCallExp
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         operationName=String0 
	 *         type=OclType? 
	 *         source=OclExpression 
	 *         (arguments+=OclExpression arguments+=OclExpression*)?
	 *     )
	 */
	protected void sequence_CollectionOperationCallExp(ISerializationContext context, CollectionOperationCallExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns CollectionType
	 *     OclType returns CollectionType
	 *     CollectionType_Impl returns CollectionType
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         name=String0 
	 *         type=OclType? 
	 *         elementType=OclType
	 *     )
	 */
	protected void sequence_CollectionType_Impl(ISerializationContext context, CollectionType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DropPattern returns DropPattern
	 *
	 * Constraint:
	 *     (location=String0? (commentsBefore+=String0 commentsBefore+=String0*)? (commentsAfter+=String0 commentsAfter+=String0*)?)
	 */
	protected void sequence_DropPattern(ISerializationContext context, DropPattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns EnumLiteralExp
	 *     EnumLiteralExp returns EnumLiteralExp
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         name=String0 
	 *         type=OclType?
	 *     )
	 */
	protected void sequence_EnumLiteralExp(ISerializationContext context, EnumLiteralExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ExpressionStat
	 *     ExpressionStat returns ExpressionStat
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         expression=OclExpression
	 *     )
	 */
	protected void sequence_ExpressionStat(ISerializationContext context, ExpressionStat semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OutPatternElement returns ForEachOutPatternElement
	 *     ForEachOutPatternElement returns ForEachOutPatternElement
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         id=String0? 
	 *         varName=String0 
	 *         (variableExp+=[VariableExp|EString] variableExp+=[VariableExp|EString]*)? 
	 *         sourceElement=[InPatternElement|EString]? 
	 *         model=[OclModel|EString]? 
	 *         type=OclType? 
	 *         initExpression=OclExpression? 
	 *         (bindings+=Binding bindings+=Binding*)? 
	 *         collection=OclExpression 
	 *         iterator=Iterator
	 *     )
	 */
	protected void sequence_ForEachOutPatternElement(ISerializationContext context, ForEachOutPatternElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ForStat
	 *     ForStat returns ForStat
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         iterator=Iterator 
	 *         collection=OclExpression 
	 *         (statements+=Statement statements+=Statement*)?
	 *     )
	 */
	protected void sequence_ForStat(ISerializationContext context, ForStat semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModuleElement returns Helper
	 *     Helper returns Helper
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         definition=OclFeatureDefinition
	 *     )
	 */
	protected void sequence_Helper(ISerializationContext context, Helper semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns IfExp
	 *     IfExp returns IfExp
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         type=OclType? 
	 *         thenExpression=OclExpression 
	 *         condition=OclExpression 
	 *         elseExpression=OclExpression
	 *     )
	 */
	protected void sequence_IfExp(ISerializationContext context, IfExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IfStat
	 *     IfStat returns IfStat
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         condition=OclExpression 
	 *         (thenStatements+=Statement thenStatements+=Statement*)? 
	 *         (elseStatements+=Statement elseStatements+=Statement*)?
	 *     )
	 */
	protected void sequence_IfStat(ISerializationContext context, IfStat semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InPattern returns InPattern
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         elements+=InPatternElement 
	 *         elements+=InPatternElement* 
	 *         filter=OclExpression?
	 *     )
	 */
	protected void sequence_InPattern(ISerializationContext context, InPattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns IntegerExp
	 *     IntegerExp returns IntegerExp
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         integerSymbol=Integer 
	 *         type=OclType?
	 *     )
	 */
	protected void sequence_IntegerExp(ISerializationContext context, IntegerExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns IntegerType
	 *     OclType returns IntegerType
	 *     IntegerType returns IntegerType
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         name=String0 
	 *         type=OclType?
	 *     )
	 */
	protected void sequence_IntegerType(ISerializationContext context, IntegerType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns IterateExp
	 *     IterateExp returns IterateExp
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         type=OclType? 
	 *         source=OclExpression 
	 *         body=OclExpression 
	 *         iterators+=Iterator 
	 *         iterators+=Iterator* 
	 *         result=VariableDeclaration
	 *     )
	 */
	protected void sequence_IterateExp(ISerializationContext context, IterateExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns IteratorExp
	 *     IteratorExp returns IteratorExp
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         name=String0 
	 *         type=OclType? 
	 *         source=OclExpression 
	 *         body=OclExpression 
	 *         iterators+=Iterator 
	 *         iterators+=Iterator*
	 *     )
	 */
	protected void sequence_IteratorExp(ISerializationContext context, IteratorExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclaration returns Iterator
	 *     Iterator returns Iterator
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         id=String0? 
	 *         varName=String0 
	 *         (variableExp+=[VariableExp|EString] variableExp+=[VariableExp|EString]*)? 
	 *         type=OclType? 
	 *         initExpression=OclExpression?
	 *     )
	 */
	protected void sequence_Iterator(ISerializationContext context, Iterator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModuleElement returns LazyMatchedRule
	 *     MatchedRule returns LazyMatchedRule
	 *     LazyMatchedRule returns LazyMatchedRule
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         name=String0 
	 *         isAbstract=Boolean 
	 *         isRefining=Boolean 
	 *         isNoDefault=Boolean 
	 *         isUnique=Boolean 
	 *         (children+=[MatchedRule|EString] children+=[MatchedRule|EString]*)? 
	 *         superRule=[MatchedRule|EString]? 
	 *         outPattern=OutPattern? 
	 *         actionBlock=ActionBlock? 
	 *         (variables+=RuleVariableDeclaration variables+=RuleVariableDeclaration*)? 
	 *         inPattern=InPattern?
	 *     )
	 */
	protected void sequence_LazyMatchedRule(ISerializationContext context, LazyMatchedRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns LetExp
	 *     LetExp returns LetExp
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         type=OclType? 
	 *         variable=VariableDeclaration 
	 *         in_=OclExpression
	 *     )
	 */
	protected void sequence_LetExp(ISerializationContext context, LetExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LibraryRef returns LibraryRef
	 *
	 * Constraint:
	 *     (location=String0? (commentsBefore+=String0 commentsBefore+=String0*)? (commentsAfter+=String0 commentsAfter+=String0*)? name=String0)
	 */
	protected void sequence_LibraryRef(ISerializationContext context, LibraryRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Library returns Library
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         name=String0 
	 *         (libraries+=LibraryRef libraries+=LibraryRef*)? 
	 *         (helpers+=Helper helpers+=Helper*)?
	 *     )
	 */
	protected void sequence_Library(ISerializationContext context, Library semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MapElement returns MapElement
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         key=OclExpression 
	 *         value=OclExpression
	 *     )
	 */
	protected void sequence_MapElement(ISerializationContext context, MapElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns MapExp
	 *     MapExp returns MapExp
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         type=OclType? 
	 *         (elements+=MapElement elements+=MapElement*)?
	 *     )
	 */
	protected void sequence_MapExp(ISerializationContext context, MapExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns MapType
	 *     OclType returns MapType
	 *     MapType returns MapType
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         name=String0 
	 *         type=OclType? 
	 *         valueType=OclType 
	 *         keyType=OclType
	 *     )
	 */
	protected void sequence_MapType(ISerializationContext context, MapType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModuleElement returns MatchedRule
	 *     MatchedRule returns MatchedRule
	 *     MatchedRule_Impl returns MatchedRule
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         name=String0 
	 *         isAbstract=Boolean 
	 *         isRefining=Boolean 
	 *         isNoDefault=Boolean 
	 *         (children+=[MatchedRule|EString] children+=[MatchedRule|EString]*)? 
	 *         superRule=[MatchedRule|EString]? 
	 *         outPattern=OutPattern? 
	 *         actionBlock=ActionBlock? 
	 *         (variables+=RuleVariableDeclaration variables+=RuleVariableDeclaration*)? 
	 *         inPattern=InPattern?
	 *     )
	 */
	protected void sequence_MatchedRule_Impl(ISerializationContext context, MatchedRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Module returns Module
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         name=String0 
	 *         isRefining=Boolean 
	 *         (libraries+=LibraryRef libraries+=LibraryRef*)? 
	 *         inModels+=OclModel 
	 *         inModels+=OclModel* 
	 *         outModels+=OclModel 
	 *         outModels+=OclModel* 
	 *         (elements+=ModuleElement elements+=ModuleElement*)?
	 *     )
	 */
	protected void sequence_Module(ISerializationContext context, Module semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns NavigationOrAttributeCallExp
	 *     NavigationOrAttributeCallExp returns NavigationOrAttributeCallExp
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         name=String0 
	 *         type=OclType? 
	 *         source=OclExpression
	 *     )
	 */
	protected void sequence_NavigationOrAttributeCallExp(ISerializationContext context, NavigationOrAttributeCallExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns OclAnyType
	 *     OclType returns OclAnyType
	 *     OclAnyType returns OclAnyType
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         name=String0 
	 *         type=OclType?
	 *     )
	 */
	protected void sequence_OclAnyType(ISerializationContext context, OclAnyType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclContextDefinition returns OclContextDefinition
	 *
	 * Constraint:
	 *     (location=String0? (commentsBefore+=String0 commentsBefore+=String0*)? (commentsAfter+=String0 commentsAfter+=String0*)? context_=OclType)
	 */
	protected void sequence_OclContextDefinition(ISerializationContext context, OclContextDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclFeatureDefinition returns OclFeatureDefinition
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         feature=OclFeature 
	 *         context_=OclContextDefinition?
	 *     )
	 */
	protected void sequence_OclFeatureDefinition(ISerializationContext context, OclFeatureDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns OclModelElement
	 *     OclType returns OclModelElement
	 *     OclModelElement returns OclModelElement
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         name=String0 
	 *         model=[OclModel|EString] 
	 *         type=OclType?
	 *     )
	 */
	protected void sequence_OclModelElement(ISerializationContext context, OclModelElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclModel returns OclModel
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         name=String0 
	 *         metamodel=[OclModel|EString] 
	 *         (elements+=[OclModelElement|EString] elements+=[OclModelElement|EString]*)? 
	 *         (model+=[OclModel|EString] model+=[OclModel|EString]*)?
	 *     )
	 */
	protected void sequence_OclModel(ISerializationContext context, OclModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns OclType
	 *     OclType returns OclType
	 *     OclType_Impl returns OclType
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         name=String0 
	 *         type=OclType?
	 *     )
	 */
	protected void sequence_OclType_Impl(ISerializationContext context, OclType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns OclUndefinedExp
	 *     OclUndefinedExp returns OclUndefinedExp
	 *
	 * Constraint:
	 *     (location=String0? (commentsBefore+=String0 commentsBefore+=String0*)? (commentsAfter+=String0 commentsAfter+=String0*)? type=OclType?)
	 */
	protected void sequence_OclUndefinedExp(ISerializationContext context, OclUndefinedExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns OperationCallExp
	 *     OperationCallExp_Impl returns OperationCallExp
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         operationName=String0 
	 *         type=OclType? 
	 *         source=OclExpression 
	 *         (arguments+=OclExpression arguments+=OclExpression*)?
	 *     )
	 */
	protected void sequence_OperationCallExp_Impl(ISerializationContext context, OperationCallExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclFeature returns Operation
	 *     Operation returns Operation
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         name=String0 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         returnType=OclType 
	 *         body=OclExpression
	 *     )
	 */
	protected void sequence_Operation(ISerializationContext context, Operation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns OperatorCallExp
	 *     OperatorCallExp returns OperatorCallExp
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         operationName=String0 
	 *         type=OclType? 
	 *         source=OclExpression 
	 *         (arguments+=OclExpression arguments+=OclExpression*)?
	 *     )
	 */
	protected void sequence_OperatorCallExp(ISerializationContext context, OperatorCallExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns OrderedSetExp
	 *     OrderedSetExp returns OrderedSetExp
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         type=OclType? 
	 *         (elements+=OclExpression elements+=OclExpression*)?
	 *     )
	 */
	protected void sequence_OrderedSetExp(ISerializationContext context, OrderedSetExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns OrderedSetType
	 *     OclType returns OrderedSetType
	 *     OrderedSetType returns OrderedSetType
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         name=String0 
	 *         type=OclType? 
	 *         elementType=OclType
	 *     )
	 */
	protected void sequence_OrderedSetType(ISerializationContext context, OrderedSetType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OutPattern returns OutPattern
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         dropPattern=DropPattern? 
	 *         elements+=OutPatternElement 
	 *         elements+=OutPatternElement*
	 *     )
	 */
	protected void sequence_OutPattern(ISerializationContext context, OutPattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclaration returns Parameter
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         id=String0? 
	 *         varName=String0 
	 *         (variableExp+=[VariableExp|EString] variableExp+=[VariableExp|EString]*)? 
	 *         type=OclType? 
	 *         initExpression=OclExpression?
	 *     )
	 */
	protected void sequence_Parameter(ISerializationContext context, ocl.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Query returns Query
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         name=String0 
	 *         (libraries+=LibraryRef libraries+=LibraryRef*)? 
	 *         body=OclExpression 
	 *         (helpers+=Helper helpers+=Helper*)?
	 *     )
	 */
	protected void sequence_Query(ISerializationContext context, Query semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns RealExp
	 *     RealExp returns RealExp
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         realSymbol=Double 
	 *         type=OclType?
	 *     )
	 */
	protected void sequence_RealExp(ISerializationContext context, RealExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns RealType
	 *     OclType returns RealType
	 *     RealType returns RealType
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         name=String0 
	 *         type=OclType?
	 *     )
	 */
	protected void sequence_RealType(ISerializationContext context, RealType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RuleVariableDeclaration returns RuleVariableDeclaration
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         id=String0? 
	 *         varName=String0 
	 *         (variableExp+=[VariableExp|EString] variableExp+=[VariableExp|EString]*)? 
	 *         type=OclType? 
	 *         initExpression=OclExpression?
	 *     )
	 */
	protected void sequence_RuleVariableDeclaration(ISerializationContext context, RuleVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns SequenceExp
	 *     SequenceExp returns SequenceExp
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         type=OclType? 
	 *         (elements+=OclExpression elements+=OclExpression*)?
	 *     )
	 */
	protected void sequence_SequenceExp(ISerializationContext context, SequenceExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns SequenceType
	 *     OclType returns SequenceType
	 *     SequenceType returns SequenceType
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         name=String0 
	 *         type=OclType? 
	 *         elementType=OclType
	 *     )
	 */
	protected void sequence_SequenceType(ISerializationContext context, SequenceType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns SetExp
	 *     SetExp returns SetExp
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         type=OclType? 
	 *         (elements+=OclExpression elements+=OclExpression*)?
	 *     )
	 */
	protected void sequence_SetExp(ISerializationContext context, SetExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns SetType
	 *     OclType returns SetType
	 *     SetType returns SetType
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         name=String0 
	 *         type=OclType? 
	 *         elementType=OclType
	 *     )
	 */
	protected void sequence_SetType(ISerializationContext context, SetType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InPatternElement returns SimpleInPatternElement
	 *     SimpleInPatternElement returns SimpleInPatternElement
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         id=String0? 
	 *         varName=String0 
	 *         (variableExp+=[VariableExp|EString] variableExp+=[VariableExp|EString]*)? 
	 *         mapsTo=[OutPatternElement|EString] 
	 *         (models+=[OclModel|EString] models+=[OclModel|EString]*)? 
	 *         type=OclType? 
	 *         initExpression=OclExpression?
	 *     )
	 */
	protected void sequence_SimpleInPatternElement(ISerializationContext context, SimpleInPatternElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OutPatternElement returns SimpleOutPatternElement
	 *     SimpleOutPatternElement returns SimpleOutPatternElement
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         id=String0? 
	 *         varName=String0 
	 *         (variableExp+=[VariableExp|EString] variableExp+=[VariableExp|EString]*)? 
	 *         sourceElement=[InPatternElement|EString]? 
	 *         model=[OclModel|EString]? 
	 *         type=OclType? 
	 *         initExpression=OclExpression? 
	 *         (bindings+=Binding bindings+=Binding*)? 
	 *         (reverseBindings+=OclExpression reverseBindings+=OclExpression*)?
	 *     )
	 */
	protected void sequence_SimpleOutPatternElement(ISerializationContext context, SimpleOutPatternElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns StringExp
	 *     StringExp returns StringExp
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         stringSymbol=String0 
	 *         type=OclType?
	 *     )
	 */
	protected void sequence_StringExp(ISerializationContext context, StringExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns StringType
	 *     OclType returns StringType
	 *     StringType returns StringType
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         name=String0 
	 *         type=OclType?
	 *     )
	 */
	protected void sequence_StringType(ISerializationContext context, StringType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns SuperExp
	 *     SuperExp returns SuperExp
	 *
	 * Constraint:
	 *     (location=String0? (commentsBefore+=String0 commentsBefore+=String0*)? (commentsAfter+=String0 commentsAfter+=String0*)? type=OclType?)
	 */
	protected void sequence_SuperExp(ISerializationContext context, SuperExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns TupleExp
	 *     TupleExp returns TupleExp
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         type=OclType? 
	 *         (tuplePart+=TuplePart tuplePart+=TuplePart*)?
	 *     )
	 */
	protected void sequence_TupleExp(ISerializationContext context, TupleExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclaration returns TuplePart
	 *     TuplePart returns TuplePart
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         id=String0? 
	 *         varName=String0 
	 *         (variableExp+=[VariableExp|EString] variableExp+=[VariableExp|EString]*)? 
	 *         type=OclType? 
	 *         initExpression=OclExpression?
	 *     )
	 */
	protected void sequence_TuplePart(ISerializationContext context, TuplePart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TupleTypeAttribute returns TupleTypeAttribute
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         name=String0 
	 *         type=OclType
	 *     )
	 */
	protected void sequence_TupleTypeAttribute(ISerializationContext context, TupleTypeAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns TupleType
	 *     OclType returns TupleType
	 *     TupleType returns TupleType
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         name=String0 
	 *         type=OclType? 
	 *         (attributes+=TupleTypeAttribute attributes+=TupleTypeAttribute*)?
	 *     )
	 */
	protected void sequence_TupleType(ISerializationContext context, TupleType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Unit_Impl returns Unit
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         name=String0 
	 *         (libraries+=LibraryRef libraries+=LibraryRef*)?
	 *     )
	 */
	protected void sequence_Unit_Impl(ISerializationContext context, Unit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclaration returns VariableDeclaration
	 *     VariableDeclaration_Impl returns VariableDeclaration
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         id=String0? 
	 *         varName=String0 
	 *         (variableExp+=[VariableExp|EString] variableExp+=[VariableExp|EString]*)? 
	 *         type=OclType? 
	 *         initExpression=OclExpression?
	 *     )
	 */
	protected void sequence_VariableDeclaration_Impl(ISerializationContext context, VariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns VariableExp
	 *     VariableExp returns VariableExp
	 *
	 * Constraint:
	 *     (
	 *         location=String0? 
	 *         (commentsBefore+=String0 commentsBefore+=String0*)? 
	 *         (commentsAfter+=String0 commentsAfter+=String0*)? 
	 *         referredVariable=[VariableDeclaration|EString] 
	 *         type=OclType?
	 *     )
	 */
	protected void sequence_VariableExp(ISerializationContext context, VariableExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
