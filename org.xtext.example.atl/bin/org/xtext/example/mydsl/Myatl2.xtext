grammar org.xtext.example.mydsl.Myatl2 hidden (WS, DOCUMENTATION, ML_COMMENT, SL_COMMENT)

//generate myDsl "http://www.xtext.org/example/mydsl/MyDsl"


import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "platform:/resource/org.xtext.example.atl/src/org/xtext/example/mydsl/EssentialOCLCST.ecore"
import "platform:/resource/org.xtext.example.atl/src/org/xtext/example/mydsl/BaseCST.ecore"
import "platform:/resource/org.xtext.example.atl/src/org/xtext/example/mydsl/pivot.ecore"



//import "http://www.eclipse.org/ocl/2015/BaseCS" as base
//import "http://www.eclipse.org/ocl/2015/Pivot" as pivot
//import "http://www.eclipse.org/ocl/2015/EssentialOCLCS"



Model returns ContextCS:
	ownedExpression=ExpCS;
	
terminal DOUBLE_QUOTED_STRING:
	'"' ('\\'('b' | 't'| 'n' | 'f' | 'r'  | 'u'  | '"'  | "'"
		| '\\') | !('\\' | '"'))* '"'	
;

terminal SINGLE_QUOTED_STRING:
	"'" ('\\'('b' | 't'| 'n' | 'f' | 'r'  | 'u'  | '"'  | "'"
		| '\\') | !('\\' | "'"))* "'"	
;
terminal ML_SINGLE_QUOTED_STRING:
	"/'"->"'/"
;
terminal SIMPLE_ID:
	('a'..'z' | 'A'..'Z'|'_') ('a'..'z'|'A'..'Z' | '_' | '0'..'9')*
;

terminal BIG_INT returns ecore::EBigInteger:
	('0'..'9')+
;
terminal DOCUMENTATION:
	'/**'->'*/'
;

terminal ML_COMMENT:
	'/*' !('\n' | '\r')* ('\r'? '\n')?
;

terminal SL_COMMENT:
	'--' !('\n' | '\r')* ('\r'? '\n')?
;
terminal WS:
	(' ' | '\t' | '\r'| '\n')+
;
terminal ANY_OTHER:
	.
;

EssentialOCLRersevedKeyword:
	'and' | 'else' | 'endif' | 'if' | 'implies' | 'in' | 'let' 
	| 'not' | 'or' | 'then' | 'xor'
;
EssentialOCLPrefixOperator:
	'-' | 'not'
;
EssentialOCLInfixOperator:
	'*' | '/' | '+' | '-' | '>' | '<' | '>=' | '<=' | '=' | '<>' | 'and'
	| 'or' | 'xor' | 'implies'
;
EssentialOCLNavigationOperator:
	'.' | '->'
;

StringLiteral:
	SINGLE_QUOTED_STRING
;

PrefixOperator:
	EssentialOCLPrefixOperator
;
InfixOperator:
	EssentialOCLInfixOperator
;
NavigationOperator:
	EssentialOCLNavigationOperator
;



EssentialOCLUnrestrictedName returns ecore::EString:
	SIMPLE_ID
;

UnrestrictedName returns ecore::EString:
	EssentialOCLUnrestrictedName
;

EssentialOCLUnreservedName returns ecore::EString:
	UnrestrictedName | CollectionTypeIdentifier |  PrimitiveTypeIdentifier | 'Tuple'
	
;
UnreservedName returns ecore::EString:
	EssentialOCLUnreservedName
;
PrimitiveTypeIdentifier:
	'Boolean' | 'Integer' | 'Real' | 'String' | 'UnlimitedNatural' | 'OclAny'
	| 'OclInvalid' | 'OclVoid'
;
PrimitiveTypeCS returns PrimitiveTypeRefCS:
	name=PrimitiveTypeIdentifier
;
CollectionTypeIdentifier returns ecore::EString:
	'Set' | 'Bag' | 'Sequence' | 'Collection' | 'OrderedSet'
;
CollectionTypeCS returns CollectionTypeCS:
	name=CollectionTypeIdentifier (('(' ownedType=TypeExpCS ')')
		| ('<' ownedType=TypeExpCS '>'))?
;

//LA regola non è LL, quindi crea problemi, riscrivere bene e decommentarla.
/* 
TupleTypeCS returns TupleTypeCS:
	name='Tuple'
	(('(' (ownedParts+=tuplePartCS (',' ownedParts+=tuplePartCS)*)? ')')
		| ('<' (ownedParts+=tuplePartCS (',' ownedParts+=tuplePartCS)*)?'>'))?
;
* */

tuplePartCS returns TuplePartCS:
	name=UnrestrictedName ':' ownedType=TypeExpCS
;

CollectionLiteralExpCS returns CollectionLiteralExpCS:
	ownedType=CollectionTypeCS
	'{' (ownedParts+=CollectionLiteralPartCS (',' ownedParts+=CollectionLiteralPartCS)*)?'}'
;
CollectionLiteralPartCS returns CollectionLiteralPartCS:
	expressionCS=ExpCS ('..' lastExpressionCS=ExpCS)?
;

PrimitiveLiteralExpCS returns PrimitiveLiteralExpCS:
	NumberLiteralExpCS | StringLiteralExpCS | BooleanLiteralExpCS 
	| UnlimitedNaturalLiteralExpCS | InvalidLiteralExpCS | NullLiteralExpCS
;
TupleLiteralExpCS returns TupleLiteralExpCS:
	'Tuple' '{' ownedParts+=TupleLiteralPartCS (','
		ownedParts+=TupleLiteralPartCS)* '}'
;
TupleLiteralPartCS returns TupleLiteralPartCS:
	name=UnrestrictedName (':' ownedType=TypeExpCS)? '='
	initExpression=ExpCS
;
NumberLiteralExpCS returns NumberLiteralExpCS:
	name=BIG_INT
;
StringLiteralExpCS returns StringLiteralExpCS:
	name+=StringLiteral
;
BooleanLiteralExpCS returns BooleanLiteralExpCS:
	name='true' | name='false'
	
;

UnlimitedNaturalLiteralExpCS returns UnlimitedNaturalLiteralExpCS:
	{UnlimitedNaturalLiteralExpCS} '*'
;
InvalidLiteralExpCS returns InvalidLiteralExpCS:
	{InvalidLiteralExpCS} 'invalid'
;
NullLiteralExpCS returns NullLiteralExpCS:
	{NullLiteralExpCS} 'null'
;



TypeLiteralCS returns TypedRefCS:
	PrimitiveTypeCS  //| TupleTypeCS
;

/*
TypeLiteralCS returns TypeLiteralExpCS:
	PrimitiveTypeCS | CollectionTypeCS | TupleTypeCS
;
*/
TypeLiteralExpCS returns TypeLiteralExpCS:
	ownedType=TypeLiteralCS
;

 
TypeNameExpCS returns TypeNameExpCS:
	//(((namespace+=UnrestrictedName '::'
		//(namespace +=UnreservedName '::')*)
		//element=UnreservedName) | element=UnrestrictedName);
			EssentialOCLUnrestrictedName;


TypeExpCS returns TypedRefCS:
	TypeNameExpCS | TypeLiteralCS
;
	


NavigatingArgCS returns NavigatingArgCS:
	name=NavigatingArgExpCS (':' ownedType=TypeExpCS)? ('=' init=ExpCS)?;
	
NavigatingBarArgCS returns NavigatingArgCS:
	prefix='|' name=NavigatingArgExpCS (':' ownedType=TypeExpCS)? ('=' init=ExpCS)?;

NavigatingCommaArgCS returns NavigatingArgCS:
	prefix=',' name=NavigatingArgExpCS (':' ownedType=TypeExpCS)? ('=' init=ExpCS)?;
		
NavigatingSemiArgCS returns NavigatingArgCS:
	prefix=';' name=NavigatingArgExpCS (':' ownedType=TypeExpCS)? ('=' init=ExpCS)?;

NavigatingArgExpCS returns ExpCS:
	ExpCS;
	
IfExpCS returns IfExpCS:
	'if' condition=ExpCS
	'then' thenExpression=ExpCS
	'else' elseExpression=ExpCS
	'endif';
LetExpCS returns LetExpCS:
	'let' variable+=LetVariableCS (',' variable+=LetVariableCS)*
	'in' in=ExpCS;
	
LetVariableCS returns LetVariableCS:
	name=UnrestrictedName (':'ownedType=TypeExpCS)? '='
	initExpression=ExpCS;
	
NestedExpCS returns NestedExpCS:
	'(' source=ExpCS ')';
	
SelfExpCS returns SelfExpCS:
	{SelfExpCS}'self';
	
PrimaryExpCS returns ExpCS:
	NavigatingExpCS | SelfExpCS | PrimitiveLiteralExpCS | TupleLiteralExpCS |
	CollectionLiteralExpCS | TypeLiteralExpCS | LetExpCS | IfExpCS | NestedExpCS;
	
NameExpCS returns NameExpCS:
	//(((namespace+=UnrestrictedName '::'
	//	(namespace +=UnreservedName '::')*)
	//	element=UnreservedName) | element=UnrestrictedName);
		EssentialOCLUnrestrictedName
		;
ExpCS returns ExpCS:
	InfixedExpCS
;


InfixedExpCS returns ExpCS:
	PrefixedExpCS ({InfixExpCS.ownedExpression+=current}
	(ownedOperator+=BinaryOperatorCS ownedExpression+=PrefixedExpCS)+)? ;

BinaryOperatorCS returns BinaryOperatorCS:
	InfixOperatorCS | NavigationOperatorCS ;
	
InfixOperatorCS returns BinaryOperatorCS:
	name=InfixOperator ;
	
NavigationOperatorCS returns BinaryOperatorCS:
	name=NavigationOperator ;


PrefixedExpCS returns ExpCS:
	PrimaryExpCS | ({PrefixExpCS} ownedOperator+=UnaryOperatorCS+
		ownedExpression=PrimaryExpCS) ;
		
UnaryOperatorCS returns UnaryOperatorCS:
	name=PrefixOperator ;
	

IndexExpCS returns NamedExpCS:
	NameExpCS
	({IndexExpCS.namedExp=current}
		'[' firstIndexes+=ExpCS (',' firstIndexes+=ExpCS)* ']'
		('[' secondIndexes+=ExpCS (',' secondIndexes+=ExpCS)* ']')?)?;
		
NavigatingExpCS_Base returns NamedExpCS:
	IndexExpCS
;

NavigatingExpCS returns NamedExpCS:
	NavigatingExpCS_Base 
	({NavigatingExpCS.namedExp=current}
		'(' (argument+=NavigatingArgCS (argument+=NavigatingCommaArgCS)*
			(argument+=NavigatingSemiArgCS
				(argument+=NavigatingCommaArgCS)*)?
				(argument+=NavigatingBarArgCS (argument+=NavigatingCommaArgCS)*)?)?')'
					) ?;
/*
NavigatingExpCS_Base returns NamedExpCS:
		'a'
;*/