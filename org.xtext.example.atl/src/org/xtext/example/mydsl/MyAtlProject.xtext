// automatically generated by Xtext
grammar org.xtext.example.mydsl.MyAtlProject hidden (WS, DOCUMENTATION, ML_COMMENT, SL_COMMENT)
//RIMUOVERE HIDDEN e mettere with org.xtext.example.mydsl.Myatl2

//generate myDsl "http://www.xtext.org/example/mydsl/MyAtlProject"


//import "http://www.eclipse.org/gmt/2005/ATL" 
//import "http://www.eclipse.org/gmt/2005/ATL-PrimitiveTypes" as PrimitiveTypes
//import "http://www.eclipse.org/gmt/2005/OCL" as ocl
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "platform:/resource/org.xtext.example.atl/src/org/xtext/example/mydsl/ATL.ecore"

//import "platform:/resource/de.covol.oc1.cst/model/EssentialOCLCST.ecore" as ocl
//import "platform:/resource/org.eclipse.ocl.xtext.essentialocl/model/EssentialOCLCS.ecore"

//RIMUOVERE
import "platform:/resource/org.xtext.example.atl/src/org/xtext/example/mydsl/EssentialOCLCST.ecore"
import "platform:/resource/org.xtext.example.atl/src/org/xtext/example/mydsl/BaseCST.ecore"
import "platform:/resource/org.xtext.example.atl/src/org/xtext/example/mydsl/pivot.ecore"





Module returns Module:
	'module'
	name=UnrestrictedName';'
	'create' 'OUT' ':' //outModels+=NameExpCS	(","outModels+=NameExpCS)*
	'from' 'IN' ':' //inModels+=NameExpCS	(","inModels+=NameExpCS)* ';'
	elements+=ModuleElement*;

ModuleElement returns ModuleElement: 
	Helper | MatchedRule | CalledRule;

MatchedRule returns MatchedRule: 
	'rule' name=UnrestrictedName '{'
		'from'
		inPattern=InPattern 
		('using' '{'
		variables += RuleVariableDeclaration*
		'}')?
		'to'
		outPattern=OutPattern
		('do' '{'
			actionBlock=ActionBlock
			'}'
		)?
	'}'
;

CalledRule returns CalledRule:
	('entrypoint')? 'rule' name=UnrestrictedName
	('('')')? '{'
		('using' '{'
		variables += RuleVariableDeclaration*
		'}')?
		'to'
		outPattern=OutPattern
		('do' '{'
			actionBlock=ActionBlock
		'}'
		)?
	'}'
;

/*
 *helper [context context type]? def :
 *helper_name(parameters) : return_type = exp;
 */

Helper returns Helper:
	'helper' ('context')?
	//definition=ATLDefCS
;

/*
 *Implementation of Complete OGL Parts for ATL.
 *Adaption, ATL hac nome differences; 'context' is not
 *optional in OCL.
 *OCL DefCS requires 'stat1c' key word.
 */

/* 
ATLDefCS returns ATLDefCS:
	'def' ':' varName=UnrestrictedName
	('('
	(parameters+=ATLParameterCS (','
		parameters+=ATLParameterCS)*)?
	')')?
	':' type=ATLType
	'=' initExpression=ExpCS ';'
;
*/
/*
ATLParameterCS returns ATLParameterCS:
	varName=UnrestrictedName ':' type=ATLType
;
*/
RuleVariableDeclaration returns RuleVariableDeclaration:
	varName=UnrestrictedName ':' //type=ATLType 
		'=' //initExpression=ExpCS ';'
;


InPattern returns InPattern:
	elements+=InPatternElement ('('
	//filter=ExpCS?
	')')?
;

InPatternElement returns SimpleInPatternElement :
	varName=UnrestrictedName ':' //type=ATLType
;


OutPattern returns OutPattern:
	elements+=OutPatternElement (','
		elements+=OutPatternElement)*
;

OutPatternElement returns OutPatternElement:
	SimpleOutPatternElement
	| ForEachOutPatternElement
;

SimpleOutPatternElement returns SimpleOutPatternElement:
	varName=UnrestrictedName ':' //type=ATLType
	('('
		(bindings+=Binding (',' bindings+=Binding)*)?
	')')?
;

ForEachOutPatternElement returns ForEachOutPatternElement:
	'xxx'
	//collection = ExpCS
	'yyy'
;

Binding:
	propertyName=UnrestrictedName '<-' //value=ExpCS
;

ActionBlock returns ActionBlock:
	statements+=Statement+
;

Statement returns Statement:
	BindingStat
;

BindingStat returns BindingStat:
	//source=ExpCS '.' 
	propertyName=UnrestrictedName '<-'
	//value=ExpCS ';'
;

/* 
ATLType returns ATLType:
	(modelName = ATLModelName '!')? type = TypeExpCS
;
*/


ATLModelName returns ecore::EString:
	UnrestrictedName;


//EString returns ecore::EString:
//'EString'; 

//RIMUOVERE DA QUA IN GIU

Model returns ContextCS:
	ownedExpression=ExpCS;
	
terminal DOUBLE_QUOTED_STRING:
	'"' ('\\'('b' | 't'| 'n' | 'f' | 'r'  | 'u'  | '"'  | "'"
		| '\\') | !('\\' | '"'))* '"'	
;

terminal SINGLE_QUOTED_STRING:
	"'" ('\\'('b' | 't'| 'n' | 'f' | 'r'  | 'u'  | '"'  | "'"
		| '\\') | !('\\' | "'"))* "'"	
;
terminal ML_SINGLE_QUOTED_STRING:
	"/'"->"'/"
;
terminal SIMPLE_ID:
	('a'..'z' | 'A'..'Z'|'_') ('a'..'z'|'A'..'Z' | '_' | '0'..'9')*
;

terminal BIG_INT returns ecore::EBigInteger:
	('0'..'9')+
;
terminal DOCUMENTATION:
	'/**'->'*/'
;

terminal ML_COMMENT:
	'/*' !('\n' | '\r')* ('\r'? '\n')?
;

terminal SL_COMMENT:
	'--' !('\n' | '\r')* ('\r'? '\n')?
;
terminal WS:
	(' ' | '\t' | '\r'| '\n')+
;
terminal ANY_OTHER:
	.
;

EssentialOCLRersevedKeyword:
	'and' | 'else' | 'endif' | 'if' | 'implies' | 'in' | 'let' 
	| 'not' | 'or' | 'then' | 'xor'
;
EssentialOCLPrefixOperator:
	'-' | 'not'
;
EssentialOCLInfixOperator:
	'*' | '/' | '+' | '-' | '>' | '<' | '>=' | '<=' | '=' | '<>' | 'and'
	| 'or' | 'xor' | 'implies'
;
EssentialOCLNavigationOperator:
	'.' | '->'
;

StringLiteral:
	SINGLE_QUOTED_STRING
;

PrefixOperator:
	EssentialOCLPrefixOperator
;
InfixOperator:
	EssentialOCLInfixOperator
;
NavigationOperator:
	EssentialOCLNavigationOperator
;



EssentialOCLUnrestrictedName returns ecore::EString:
	SIMPLE_ID
;

UnrestrictedName returns ecore::EString:
	EssentialOCLUnrestrictedName
;

EssentialOCLUnreservedName returns ecore::EString:
	UnrestrictedName | CollectionTypeIdentifier |  PrimitiveTypeIdentifier | 'Tuple'
	
;
UnreservedName returns ecore::EString:
	EssentialOCLUnreservedName
;
PrimitiveTypeIdentifier:
	'Boolean' | 'Integer' | 'Real' | 'String' | 'UnlimitedNatural' | 'OclAny'
	| 'OclInvalid' | 'OclVoid'
;
PrimitiveTypeCS returns PrimitiveTypeRefCS:
	name=PrimitiveTypeIdentifier
;
CollectionTypeIdentifier returns ecore::EString:
	'Set' | 'Bag' | 'Sequence' | 'Collection' | 'OrderedSet'
;
CollectionTypeCS returns CollectionTypeCS:
	name=CollectionTypeIdentifier (('(' ownedType=TypeExpCS ')')
		| ('<' ownedType=TypeExpCS '>'))?
;

//LA regola non è LL, quindi crea problemi, riscrivere bene e decommentarla.
/* 
TupleTypeCS returns TupleTypeCS:
	name='Tuple'
	(('(' (ownedParts+=tuplePartCS (',' ownedParts+=tuplePartCS)*)? ')')
		| ('<' (ownedParts+=tuplePartCS (',' ownedParts+=tuplePartCS)*)?'>'))?
;
* */

tuplePartCS returns TuplePartCS:
	name=UnrestrictedName ':' ownedType=TypeExpCS
;

CollectionLiteralExpCS returns CollectionLiteralExpCS:
	ownedType=CollectionTypeCS
	'{' (ownedParts+=CollectionLiteralPartCS (',' ownedParts+=CollectionLiteralPartCS)*)?'}'
;
CollectionLiteralPartCS returns CollectionLiteralPartCS:
	expressionCS=ExpCS ('..' lastExpressionCS=ExpCS)?
;

PrimitiveLiteralExpCS returns PrimitiveLiteralExpCS:
	NumberLiteralExpCS | StringLiteralExpCS | BooleanLiteralExpCS 
	| UnlimitedNaturalLiteralExpCS | InvalidLiteralExpCS | NullLiteralExpCS
;
TupleLiteralExpCS returns TupleLiteralExpCS:
	'Tuple' '{' ownedParts+=TupleLiteralPartCS (','
		ownedParts+=TupleLiteralPartCS)* '}'
;
TupleLiteralPartCS returns TupleLiteralPartCS:
	name=UnrestrictedName (':' ownedType=TypeExpCS)? '='
	initExpression=ExpCS
;
NumberLiteralExpCS returns NumberLiteralExpCS:
	name=BIG_INT
;
StringLiteralExpCS returns StringLiteralExpCS:
	name+=StringLiteral
;
BooleanLiteralExpCS returns BooleanLiteralExpCS:
	name='true' | name='false'
	
;

UnlimitedNaturalLiteralExpCS returns UnlimitedNaturalLiteralExpCS:
	{UnlimitedNaturalLiteralExpCS} '*'
;
InvalidLiteralExpCS returns InvalidLiteralExpCS:
	{InvalidLiteralExpCS} 'invalid'
;
NullLiteralExpCS returns NullLiteralExpCS:
	{NullLiteralExpCS} 'null'
;



TypeLiteralCS returns TypedRefCS:
	PrimitiveTypeCS  //| TupleTypeCS
;

/*
TypeLiteralCS returns TypeLiteralExpCS:
	PrimitiveTypeCS | CollectionTypeCS | TupleTypeCS
;
*/
TypeLiteralExpCS returns TypeLiteralExpCS:
	ownedType=TypeLiteralCS
;

 
TypeNameExpCS returns TypeNameExpCS:
	//(((namespace+=UnrestrictedName '::'
		//(namespace +=UnreservedName '::')*)
		//element=UnreservedName) | element=UnrestrictedName);
			EssentialOCLUnrestrictedName;


TypeExpCS returns TypedRefCS:
	TypeNameExpCS | TypeLiteralCS
;
	


NavigatingArgCS returns NavigatingArgCS:
	name=NavigatingArgExpCS (':' ownedType=TypeExpCS)? ('=' init=ExpCS)?;
	
NavigatingBarArgCS returns NavigatingArgCS:
	prefix='|' name=NavigatingArgExpCS (':' ownedType=TypeExpCS)? ('=' init=ExpCS)?;

NavigatingCommaArgCS returns NavigatingArgCS:
	prefix=',' name=NavigatingArgExpCS (':' ownedType=TypeExpCS)? ('=' init=ExpCS)?;
		
NavigatingSemiArgCS returns NavigatingArgCS:
	prefix=';' name=NavigatingArgExpCS (':' ownedType=TypeExpCS)? ('=' init=ExpCS)?;

NavigatingArgExpCS returns ExpCS:
	ExpCS;
	
IfExpCS returns IfExpCS:
	'if' condition=ExpCS
	'then' thenExpression=ExpCS
	'else' elseExpression=ExpCS
	'endif';
LetExpCS returns LetExpCS:
	'let' variable+=LetVariableCS (',' variable+=LetVariableCS)*
	'in' in=ExpCS;
	
LetVariableCS returns LetVariableCS:
	name=UnrestrictedName (':'ownedType=TypeExpCS)? '='
	initExpression=ExpCS;
	
NestedExpCS returns NestedExpCS:
	'(' source=ExpCS ')';
	
SelfExpCS returns SelfExpCS:
	{SelfExpCS}'self';
	
PrimaryExpCS returns ExpCS:
	NavigatingExpCS | SelfExpCS | PrimitiveLiteralExpCS | TupleLiteralExpCS |
	CollectionLiteralExpCS | TypeLiteralExpCS | LetExpCS | IfExpCS | NestedExpCS;
	
NameExpCS returns NameExpCS:
	//(((namespace+=UnrestrictedName '::'
	//	(namespace +=UnreservedName '::')*)
	//	element=UnreservedName) | element=UnrestrictedName);
		EssentialOCLUnrestrictedName
		;
ExpCS returns ExpCS:
	InfixedExpCS
;


InfixedExpCS returns ExpCS:
	PrefixedExpCS ({InfixExpCS.ownedExpression+=current}
	(ownedOperator+=BinaryOperatorCS ownedExpression+=PrefixedExpCS)+)? ;

BinaryOperatorCS returns BinaryOperatorCS:
	InfixOperatorCS | NavigationOperatorCS ;
	
InfixOperatorCS returns BinaryOperatorCS:
	name=InfixOperator ;
	
NavigationOperatorCS returns BinaryOperatorCS:
	name=NavigationOperator ;


PrefixedExpCS returns ExpCS:
	PrimaryExpCS | ({PrefixExpCS} ownedOperator+=UnaryOperatorCS+
		ownedExpression=PrimaryExpCS) ;
		
UnaryOperatorCS returns UnaryOperatorCS:
	name=PrefixOperator ;
	

IndexExpCS returns NamedExpCS:
	NameExpCS
	({IndexExpCS.namedExp=current}
		'[' firstIndexes+=ExpCS (',' firstIndexes+=ExpCS)* ']'
		('[' secondIndexes+=ExpCS (',' secondIndexes+=ExpCS)* ']')?)?;
		
NavigatingExpCS_Base returns NamedExpCS:
	IndexExpCS
;

NavigatingExpCS returns NamedExpCS:
	NavigatingExpCS_Base 
	({NavigatingExpCS.namedExp=current}
		'(' (argument+=NavigatingArgCS (argument+=NavigatingCommaArgCS)*
			(argument+=NavigatingSemiArgCS
				(argument+=NavigatingCommaArgCS)*)?
				(argument+=NavigatingBarArgCS (argument+=NavigatingCommaArgCS)*)?)?')'
					) ?;


